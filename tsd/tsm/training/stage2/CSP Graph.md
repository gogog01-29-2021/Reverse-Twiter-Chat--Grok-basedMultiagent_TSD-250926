## Table of Contents

- [Table of Contents](#table-of-contents)
- [What is a CSP Graph?](#what-is-a-csp-graph)
- [Create the graph](#create-the-graph)
- [Run the program](#run-the-program)
- [Visualize](#visualize)
- [Graphs connecting nodes](#graphs-connecting-nodes)
- [Anatomy of a `csp.graph`](#anatomy-of-a-cspgraph)
- [Graph Propagation and Single-Dispatch](#graph-propagation-and-single-dispatch)
- [Graph Pruning](#graph-pruning)
- [Executing a Graph](#executing-a-graph)
- [Collecting Graph Outputs](#collecting-graph-outputs)
- [Graphs vs. nodes](#graphs-vs-nodes)
- [Always use engine time](#always-use-engine-time)
- [More-with-CSP](#more-with-csp)
- [Building our Poisson counter](#building-our-poisson-counter)
- [Correlation between two Poisson processes](#correlation-between-two-poisson-processes)
- [Running the graph and analyzing results](#running-the-graph-and-analyzing-results)
- [Visualization](#visualization)

Learn how to connect these nodes into a complete system.

## What is a CSP Graph?

A csp.graph wires multiple nodes into a pipeline.

Why do we need it? Individual nodes define what to compute, but a graph defines how nodes are connected and in what order they run.

## Create the graph

Next, we will create a `csp.graph` that analyzes the log messages from our deployment. For this example, we will use simulated log messages from a `csp.curve`. 


The csp.curve() adapter is used to convert historical or static time-series data into a ticking edge inside a CSP graph.

It lets you feed a sequence of (timestamp, value) pairs into the graph as if they were real-time events.

```python
csp.curve(
    typ: 'T',
    data: typing.Union[list, tuple]
)
```

This allows you to convert a list of non-CSP data into a ticking edge in CSP

Args:

- **`typ`**: is the type of the value of the data of this edge
- **`data`**: is either a list of tuples of `(datetime, value)`, or a tuple of two equal-length numpy ndarrays, the first with datetimes and the second with values.
  In either case, that will tick on the returned edge into the engine, and the data must be in time order.
  Note that for the list of tuples case, you can also provide tuples of (timedelta, value) where timedelta will be the offset from the engine's start time.

Graph components are only executed once during application startup to construct the graph. Once the graph is constructed, `csp.graph` code is no longer needed.


```python
start = datetime(2020,1,1)
    
@csp.graph
def monitor_deployment():
    log_msgs = csp.curve(typ=str, data=[
        (start, 'WARNING: Load is heavy @ 90%'),
        (start + timedelta(minutes=1), 'INFO: New connection on port 42'),
        (start + timedelta(minutes=4), 'WARNING: Load is heavy @ 95%'),
        (start + timedelta(minutes=6), 'INFO: New connection on port 43'),
        (start + timedelta(minutes=9), 'CRITICAL: Overloaded, cannot connect new users!'),
    ])
    # Regex match in csp`
    load_warnings = csp.count(regex_match(log_msgs, r'.*WARNING.*Load.*'))
    new_connections = csp.count(regex_match(log_msgs, r'.*INFO.*New connection.*'))

    csp.print("load_warnings", load_warnings)
    csp.print("new_connections", new_connections)
```

In this graph, we count the number of load-related warnings as well as the number of new connections.

## Run the program

To execute a `csp` application we use the `run` function. Each run starts at a `starttime` and ends at an `endtime`. For the example above, we can run the graph using:


```python
csp.run(monitor_deployment, starttime=start, endtime=timedelta(minutes=10))
```

The program will produce the following:

```python-console
2020-01-01 00:00:00 load_warnings:1
2020-01-01 00:01:00 new_connections:1
2020-01-01 00:04:00 load_warnings:2
2020-01-01 00:06:00 new_connections:2
```


Take a moment to reason with this output. Each `csp.count` node is only invoked when its `regex_match` ticks a value, and each `regex_match` node only ticks a value when the match is valid.

## Visualize

To visualize this graph, you can [install `graphviz`](https://graphviz.readthedocs.io/en/stable/manual.html) and use `csp.show_graph` to view and save the image.

```python
csp.show_graph(my_graph, graph_filename="tmp.png")
```



![Output generated by show_graph](https://raw.githubusercontent.com/Point72/csp/main/docs/wiki/images/monitor-graph.png)


The blue arrows (`csp.curve`) indicate inputs and the red arrows (`csp.print`) indicate outputs. The nodes, in our case `regex_match` and `count`, are denoted by rectangles.

Check out the expanded and complete example: [e3_show_graph.py](../stage2/e3_show_graph.py).


## Graphs connecting nodes

## Anatomy of a `csp.graph`

`csp.graph` methods are called in order to construct the graph and are only executed before the engine is run. A graph is a collection of nodes and adapters which can either be executed as an argument to `csp.run` or composed into a larger graph.
The `csp.graph` decorator is only used for type validation and it is optional when creating a CSP program. A standard Python function without the decorator can also be passed as an argument to `csp.run` if type validation is not required.
`csp.graph` methods can be created to encapsulate components of a graph, and can be called from other `csp.graph` methods in order to help facilitate graph building.

Simple example:

```python
@csp.graph
def calc_user_time(session_data: ts[UserSession]) -> ts[float]:
    # sub-graph code needed to compute the time a user spends on a website
    session_time = session_data.logout_time - session_data.login_time
    time_online = csp.stats.sum(session_time)
    return time_online


@csp.graph
def calc_site_traffic(users: List[str]) -> ts[float]:
    user_time = []
    for user in users:
        user_sessions = get_session(user)
        user_time.append(calc_user_time(user_sessions))

    return csp.sum(user_time)
```

In this simple example we compute the total time all users spend on a website. We have a `csp.graph` subcomponent `calc_user_time` which computes the time a single user spends on the site throughout the run.
Then, in `calc_site_traffic` we compute the total user traffic by creating the user-level subgraph for each account and aggregating the results.

## Graph Propagation and Single-Dispatch

The CSP graph propagation algorithm ensures that all nodes are executed *after* any of their dependencies on a given engine cycle.

> [!IMPORTANT]
> An *engine cycle* refers to a single execution of a CSP graph. There can be multiple engine cycles at the same *timestamp*; for example, a single data source may have two events both at `2020-01-01 00:00:00`. These events will be executed in two *cycles* that both occur at the same timestamp. Another case where multiple cycles can occur is [csp.feedback](Add-Cycles-in-Graphs).

For example, consider the graph below:

![359407953](https://github.com/Point72/csp/assets/3105306/d9416353-6755-4e37-8467-01da516499cf)

Individuals nodes are executed in *rank order* where the rank of a node is defined as the longest path between the node and an input adapter. The "mid" node is at rank 1, while "spread" is at rank 2 and "quote" is rank 3. Therefore, if "bid" ticks on a given engine cycle then "mid" will be executed before "spread" and "quote". Note that the order of node execution *within* a rank is undefined, and users should never rely on the execution order of nodes at the same rank.

## Graph Pruning

Any node in a graph that is not connected to an output will be pruned from the graph and will not exist during runtime.
An output is defined as either an output adapter or a `csp.node` without any outputs of its own.
Pruning is an optimization which avoids executing nodes whose result will be discarded.
As a result, it's best practice for any `csp.node` to be \***side-effect free**; they shouldn't mutate any state outside of the node.

## Executing a Graph

Graphs can be executed using the `csp.run` function. Execution takes place in either real-time or historical mode (see [[Execution-Modes](../stage4/Execution-Modes.md)]) depending on the `realtime` argument. Graph execution begin at a `starttime` and ends at an `endtime`; the `endtime` argument can either be a `datetime` which is past the start *or* a `timedelta` which is the duration of the run. For example, if we wish to run our `calc_site_traffic` graph over one week of historical data we can execute it with:

```python
csp.run(calc_site_traffic, users=['alice', 'bob'], starttime=start, endtime=timedelta(weeks=1), realtime=False)
```

## Collecting Graph Outputs

There are multiple methods of getting in-process outputs after executing a `csp.graph`. If the graph returns one or more time-series, the full history of those values will be returned from `csp.run`.

**return example**

```python
import csp
from datetime import datetime, timedelta

@csp.graph
def my_graph() -> ts[int]:
    return csp.merge(csp.const(1), csp.const(2, delay=timedelta(seconds=1)))

res = csp.run(my_graph, starttime=datetime(2021,11,8))
```

res:

```raw
{0: [(datetime.datetime(2021, 11, 8, 0, 0), 1), (datetime.datetime(2021, 11, 8, 0, 0, 1), 2)]}
```

Note that the result is a list of `(time, value)` tuples. You can have the result returned as two separate NumPy arrays, one for the times and one for the values, by setting `output_numpy=True` in the `run` call.

```python
res = csp.run(my_graph, starttime=datetime(2021,11,8), output_numpy=True)
```

res:

```raw
{0: (array(['2021-11-08T00:00:00.000000000', '2021-11-08T00:00:01.000000000'], dtype='datetime64[ns]'), array([1, 2], dtype=int64))}
```

You can also use `csp.add_graph_output` to add outputs.

The `csp.add_graph_output` function is used to mark a specific edge in your graph as an output, so you can collect its data after the graph finishes running.

This is useful when you want to analyze, display, or test the values produced by a part of your pipeline.

```python
csp.add_graph_output(
    key: object,
    input: ts['T'],
    tick_count: int = -1,
    tick_history: timedelta = timedelta()
)
```

This allows you to connect an edge as a "graph output".
All edges added as outputs will be returned to the caller from `csp.run` as a dictionary of `key: [(datetime, value)]`
(list of datetime, values that ticked on the edge) or if `csp.run` is passed `output_numpy=True`, as a dictionary of
`key: (array, array)` (tuple of two numpy arrays, one with datetimes and one with values).
See [Collecting Graph Outputs](#collecting-graph-outputs)

Args:

- **`key`**: key to return the results as from `csp.run`
- **`input`**: edge to connect
- **`tick_count`**: number of ticks to keep in the buffer (defaults to -1 - all ticks)
- **`tick_history`**: amount of ticks to keep by time window (defaults to keeping all history)



These do not need to be in the top-level graph called directly from `csp.run`. Users can also specify the amount of history they want stored in the output using the `tick_count` and `tick_history` arguments to `add_graph_output`. For example, if only the last value needs to be stored set `tick_count=1`.

**add_graph_output example**

```python
@csp.graph
def my_graph():
    same_thing = csp.merge(csp.const(1), csp.const(2, delay=timedelta(seconds=1)))
    csp.add_graph_output('my_name', same_thing)

res = csp.run(my_graph, starttime=datetime(2021,11,8))
```

res:

```raw
{'my_name': [(datetime.datetime(2021, 11, 8, 0, 0), 1), (datetime.datetime(2021, 11, 8, 0, 0, 1), 2)]}
```

## Graphs vs. nodes

The most common challenge for new `csp` users is understanding the distinction between [graphs](../stage2/CSP%20Graph.md) and [nodes](../stage1/CSP%20Node.md). A few issues arise when graphs are treated like nodes and vice versa.

1. *Nodes cannot call other nodes*. Nodes themselves can be considered *atomic* computation units; they perform a single transformation at runtime and do not invoke other nodes to execute.

Example erroneous code

```python
import csp
from csp import ts

@csp.node
def square(x: ts[int]) -> ts[int]:
    return x*x

@csp.node
def cube(x: ts[int]) -> ts[int]:
    return x*square(x) 


csp.run(cube(csp.const(1)), starttime=datetime(2020,1,1), endtime=timedelta())
# the run call above will fail at runtime with the error
# ArgTypeMismatchError: In function square: Expected csp.impl.types.tstype.TsType[int] for argument 'x', got 1 (int)
# square(x) accepts a time-series of int, but when cube is invoked we are passing it the VALUE of x (an int)!
```

Corrected code - we simply make `cube` a graph, not a node.

```python
@csp.graph
def cube(x: ts[int]) -> ts[int]:
    return x*square(x) 
```

2. *Graph code does not access runtime values*. This is the inverse of (1): graph code treats all time-series as Edges and simply "wires" together the application.

Example erroneous code

```python
@csp.graph
def clip(x: ts[int], low: int, high: int) -> ts[int]:
    return min(max(x, low), high)

csp.run(clip(csp.const(3), 1, 4), starttime=datetime(2020,1,1), endtime=timedelta())
# the run fails with - ValueError: boolean evaluation of an edge is not supported
# at graph-time, x is an Edge, not a value: so comparing it to an integer doesn't make sense
# we really want to compare each value itself at runtime
```

Corrected code - we apply the `min` and `max` functions to the values, not the Edge.

```python
@csp.graph
def clip(x: ts[int], low: int, high: int) -> ts[int]:
    return csp.apply(x, lambda u: min(max(u, low), high), int)
```

## Always use engine time

Another common mistake is to use `datetime.now()` inside a `csp.node`. You should **always** use the engine time in a node by calling `csp.now()`, or else your application will not work correctly in historical mode. The *engine time* is the time that the current `csp` engine cycle started. In real-time it will be the wall clock at the time the cycle began, and in historical mode it will be the timestamp of the simulated event. The use of `csp.now()` allows the graph to be run in both execution contexts and still maintain a consistent view of the time.

Example erroneous code

```python
from typing import List

@csp.node
def next_movie_showing(show_times: ts[List[datetime]]) -> ts[datetime]:
    next_showing = None
    for time in show_times:
        if time >= datetime.now(): # list may include some shows today that have already past, so let's filter those out
            if next_showing is None or time < next_showing:
                next_showing = time

    return next_showing
```

If you only run this node in real-time, you may not notice that it has a critical error. When we run on historical data, we will not get any valid show times! The show times in historical data will be on *past* days, but `datetime.now()` will be giving us the *current* time.

Corrected code - we use `csp.now` instead of `datetime.now` so the node works on playback data.

```python
...
    for time in show_times:
            if time >= csp.now():
                ...
```


---

Nodes in `csp` have many more complex features than we saw in the [CSP Node](../stage1/CSP%20Node.md) example. These include state, alarms and start/stop execution blocks. Also, the `csp` library has an extensive set of pre-written nodes that are optimized in C++. You can leverage these nodes to quickly build high-performing applications.

In this tutorial, you will create a Poisson counter that counts the number of events in a [Poisson process](https://en.wikipedia.org/wiki/Poisson_point_process). We will then look at the correlation between two independent Poisson processes by leveraging nodes in `baselib` and `stats`.

## More-with-CSP

## Building our Poisson counter

A Poisson point process has events which are exponentially distributed across time. The average delay between events is controlled by the rate parameter "rate". In the `poisson_counter` node below, we use the following useful node features:

1. `csp.state`: we keep a *state* variable in the node which is the count of events thus far. A state variable can be thought of as a "member" of the node.
1. `csp.alarms`: we schedule an *alarm* to simulate each event. An alarm is an internal time series which feeds back to the same node.
1. `csp.start`: we schedule the first alarm at *start* time, which is when the graph begins execution. There is also a *stop* block available in nodes which runs when the graph stops.

We also turn off memoization for the node by passing `memoize=False`. This means that when we create two `poisson_counter` nodes with the same "rate" argument we get two different random time series.

```python
import csp
from csp import ts
from datetime import timedelta
import numpy as np

@csp.node(memoize=False)
def poisson_counter(rate: float) -> ts[int]:
    with csp.alarms():
        event = csp.alarm(int)
    with csp.state():
        s_count = 0
    with csp.start():
        delay = np.random.exponential(rate)
        csp.schedule_alarm(event, timedelta(seconds=delay), True)
        
    if csp.ticked(event):
        s_count += 1
        next_delay = np.random.exponential(rate)
        csp.schedule_alarm(event, timedelta(seconds=next_delay), True)
        return s_count
```

We can run the node using `csp.run` as follows:

```python
from datetime import datetime

res = csp.run(poisson_counter, rate=2.0, starttime=datetime.utcnow(), endtime=timedelta(seconds=10), realtime=False)
print(f'Final count: {res[0][-1][1]}')
```

Since the rate is set to 2.0, we would expect a new event approximately every 2.0 seconds. Therefore, the average of multiple runs should converge to 5 events. Running the counter multiple times, we get:

```raw
Final count: 6
Final count: 1
Final count: 6
Final count: 5
Final count: 5
Final count: 2
Final count: 9
...
```

## Correlation between two Poisson processes

We can use a combination of pre-written nodes from `baselib` and `stats` to calculate the correlation of two Poisson point processes in 1-minute buckets. Even though both processes have the same rate they will be fully independent, so we expect the correlation to converge to zero.

We will first compute the number of events in each 1-minute period by using the (`csp.diff`)[Base-Nodes-API#cspdiff] and (`csp.sample`)[Base-Nodes-API#cspsample] functions. `diff` gives the difference between the value of a time series at the current time and some time in the past. `sample` will get the value of a time series whenever some other time series ticks. We will also use a (`csp.timer`)[Base-Adapters-API#csptimer] so that we sample the values every minute.

```python
@csp.graph
def events_per_minute_bucket(poisson_counter: ts[int]) -> ts[int]:
    minute_timer = csp.timer(interval=timedelta(minutes=1), value=True)
    sampled_event_count = csp.sample(trigger=minute_timer, x=poisson_counter)
    events_per_minute = csp.diff(sampled_event_count, lag=timedelta(minutes=1))
    return events_per_minute
```

We can call this subgraph with two different Poisson processes of `rate=1.0` to generate our 1-minute event counts. We can then find the correlation between the two series using `csp.stats.corr`.

```python
from csp import stats

@csp.graph
def corr_graph() -> ts[float]:
    # Define two Poisson point processes
    process_A = poisson_counter(rate=1.0)
    process_B = poisson_counter(rate=1.0)
   
    # Get the per minute event counts
    counts_A = events_per_minute_bucket(process_A)
    counts_B = events_per_minute_bucket(process_B)

    # Compute correlation between two independent processes
    corr = csp.stats.corr(counts_A, counts_B)
    return corr
```

## Running the graph and analyzing results

We can run the above `corr_graph` for 2500 minutes of simulated time and analyze the correlation. Using:

```python
csp.run(corr_graph, starttime=datetime(2020,1,1), endtime=timedelta(minutes=2500), realtime=False)
```

and extracting the correlation values, we see that the correlation converges to near zero as we expected.



![Correlation graph](https://raw.githubusercontent.com/Point72/csp/main/docs/wiki/images/corr-trend.png)


## Visualization

We can visualize the graph used to calculate our autocorrelation using the `show_graph` utility. Take a moment and match each node to where it lies in the `corr_graph` code. Note that many of the nodes shown are subcomponents of the library functions we used.



![Output of show_graph](https://raw.githubusercontent.com/Point72/csp/main/docs/wiki/images/corr-graph.png)

